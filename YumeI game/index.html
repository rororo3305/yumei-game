<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ゲーム『YumeI』最終完成版プロトタイプ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(135, 206, 235, 0.5);
            position: relative;
            background-color: #75cff0;
            /* 空の色 */
            overflow: hidden;
            cursor: pointer;
        }

        canvas {
            display: block;
            background-color: transparent;
        }

        h1,
        #loading-text {
            color: #e0e0e0;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #instructions {
            margin-top: 15px;
            font-size: 1em;
            color: #aaa;
            text-align: center;
            line-height: 1.6;
        }

        #instructions span {
            display: inline-block;
            background-color: #333;
            color: #eee;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 4px;
            font-weight: bold;
        }

        .ui-text {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), -2px -2px 4px rgba(0, 0, 0, 0.8);
        }

        .wasd-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .key-row {
            display: flex;
            gap: 10px;
        }

        .key {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #ccc;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .key.pressed {
            background-color: #81C784;
            border-color: #A5D6A7;
            color: #fff;
        }

        .tutorial-text {
            bottom: 20px;
            font-size: 1.1em;
            padding: 8px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            max-width: 80%;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            line-height: 1.4;
        }

        .status-display,
        .shield-display {
            position: absolute;
            font-size: 1.2em;
            color: #fff;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .status-display {
            top: 10px;
            left: 10px;
        }

        .shield-display {
            top: 40px;
            left: 10px;
        }

        .purification-gauge-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid #fff;
            padding: 2px;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .purification-gauge {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #00BCD4, #80DEEA);
            border-radius: 8px;
            transition: width 0.2s ease-out;
        }

        .message-overlay,
        .title-screen {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            color: white;
            text-align: center;
            pointer-events: none;
        }

        .message-overlay {
            top: 40%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .title-screen {
            top: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
        }

        .title-screen h1 {
            font-size: 6em;
            margin: 0;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
        }

        .title-screen p {
            font-size: 1.5em;
            margin-top: 20px;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <h1>YumeI - チュートリアル</h1>
    <div id="game-container" style="width: 800px; height: 600px;">
        <canvas id="gameCanvas" style="display: none;"></canvas>
        <div id="wasd-guide" class="wasd-guide">
            <div class="key-row">
                <div id="key-w" class="key">W</div>
            </div>
            <div class="key-row">
                <div id="key-a" class="key">A</div>
                <div id="key-s" class="key">S</div>
                <div id="key-d" class="key">D</div>
            </div>
        </div>
        <div id="loading-text"
            style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 2em;">
            魂を吹き込み中...</div>
        <div id="dreamCollapseDisplay" class="status-display ui-text">心の崩壊度: 0%</div>
        <div id="shieldDisplay" class="shield-display ui-text">集中力: 100%</div>
        <div id="purificationGaugeContainer" class="purification-gauge-container">
            <div id="purificationGauge" class="purification-gauge"></div>
        </div>
        <div id="messageOverlay" class="message-overlay ui-text"></div>
        <div id="tutorialText" class="tutorial-text ui-text"></div>
        <div id="titleScreen" class="title-screen ui-text">
            <h1>YumeI</h1>
            <p>スペースキーで夢の中へ</p>
        </div>
    </div>

    <div id="debug-display"
        style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px; font-family: monospace; z-index: 100;">
    </div>
    <div id="instructions" style="display:none;">
        <span>WASD</span>: 移動 | <span>C</span>: ガード | <span>Shift</span>: 回避
    </div>

    <script>
        // --- ゲーム設定 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; canvas.height = 600;
        const wasdGuide = document.getElementById('wasd-guide');

        // --- キャラクター画像とアセット読み込み ---
        const assets = {
            player: { img: new Image() },
            nyarl: { img: new Image() }
        };
        const PLAYER_IMAGE_URL = 'https://placehold.co/48x48/4caf50/white?text=Hero';
        const NYARL_IMAGE_URL = 'https://placehold.co/40x40/212121/white?text=Nyarl';


        let assetsLoaded = 0;
        const totalAssetsToLoad = 2; // player, nyarl

        function onAssetLoad() {
            assetsLoaded++;
            if (assetsLoaded === totalAssetsToLoad) {
                document.getElementById('loading-text').style.display = 'none';
                canvas.style.display = 'block';
                document.getElementById('instructions').style.display = 'block';
                resetGame();
                gameLoop();
            }
        }

        assets.player.img.onload = onAssetLoad;
        assets.nyarl.img.onload = onAssetLoad;
        assets.player.img.onerror = () => { console.error("Player image failed to load."); onAssetLoad(); };
        assets.nyarl.img.onerror = () => { console.error("Nyarl image failed to load."); onAssetLoad(); };
        assets.player.img.src = PLAYER_IMAGE_URL;
        assets.nyarl.img.src = NYARL_IMAGE_URL;


        // --- サウンドエンジン ---
        let sounds = {}; let audioStarted = false; let isGuardSoundPlaying = false;
        let peacefulBGM, battleBGM;

        function setupSounds() {
            sounds = {
                dodge: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination(),
                parry: new Tone.FMSynth({ harmonicity: 2, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.3 } }).toDestination(),
                hit: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).toDestination(),
                cough: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1 } }).toDestination(),
                sneeze: new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).toDestination(),
                yawn: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.5 } }).toDestination(),
                wallBreak: new Tone.FMSynth({ volume: -10, harmonicity: 1.5, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.4, sustain: 0.1 } }).toDestination(),
                purify: new Tone.FMSynth({ harmonicity: 3, modulationIndex: 5, envelope: { attack: 0.01, decay: 1.5, sustain: 0.2 } }).toDestination(),
                guard: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -20, envelope: { attack: 0.1, decay: 0.05, sustain: 1, release: 0.2 } }).toDestination(),
                charge: new Tone.Synth({ oscillator: { type: 'sawtooth' }, volume: -15, envelope: { attack: 0.01, decay: 1.0, sustain: 1, release: 0.1 } }).toDestination()
            };
            peacefulBGM = new Tone.Sequence((time, note) => { sounds.yawn.triggerAttackRelease(note, "8n", time); }, ["C4", "E4", "G4", "C5"], "4n");
            peacefulBGM.loop = true;
            battleBGM = new Tone.Sequence((time, note) => { sounds.hit.triggerAttackRelease(note, "8n", time); }, ["C3", "C3", "G2", "C3"], "8n");
            battleBGM.loop = true;
            Tone.Transport.bpm.value = 120;
        }

        function playSound(type) { if (!audioStarted) return; try { switch (type) { case 'dodge': sounds.dodge.triggerAttackRelease(0.1); break; case 'parry': sounds.parry.triggerAttackRelease("G5", "0.2"); break; case 'hit': sounds.hit.triggerAttackRelease("C2", 0.1); break; case 'cough': sounds.cough.triggerAttackRelease(0.3); break; case 'sneeze': sounds.sneeze.triggerAttackRelease(0.1); break; case 'yawn': sounds.yawn.triggerAttackRelease("C4", "1s"); sounds.yawn.frequency.rampTo("G4", 0.5); break; case 'wallBreak': sounds.wallBreak.triggerAttackRelease("C3", "1s"); break; case 'purify': sounds.purify.triggerAttackRelease("C5", "1s"); break; case 'charge': sounds.charge.triggerAttack("C3"); sounds.charge.frequency.rampTo("C4", 1.0); break; case 'chargeRelease': sounds.charge.triggerRelease(); break; } } catch (e) { /* ignore */ } }
        let groundCloudCanvas = null; let groundCloudCtx = null; function createCloudIslandLayer(width, height, islands) { const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height; const tempCtx = tempCanvas.getContext('2d'); islands.forEach(island => { for (let i = 0; i < island.density; i++) { const offsetX = (Math.random() - 0.5) * island.sizeX * 1.1; const offsetY = (Math.random() - 0.5) * island.sizeY * 1.1; const radius = (Math.random() * 0.5 + 0.5) * (island.sizeX + island.sizeY) / 4; const gradient = tempCtx.createRadialGradient(island.x + offsetX, island.y + offsetY, radius * 0.2, island.x + offsetX, island.y + offsetY, radius); gradient.addColorStop(0, `rgba(255, 255, 255, 0.98)`); gradient.addColorStop(1, `rgba(230, 240, 255, 0.8)`); tempCtx.beginPath(); tempCtx.fillStyle = gradient; tempCtx.arc(island.x + offsetX, island.y + offsetY, radius, 0, Math.PI * 2); tempCtx.fill(); } }); groundCloudCanvas = tempCanvas; groundCloudCtx = tempCtx; return tempCanvas; } function createDistantCloudLayer(width, height, count, minR, maxR, baseAlpha) { const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height; const tempCtx = tempCanvas.getContext('2d'); for (let i = 0; i < count; i++) { const cloudX = Math.random() * width; const cloudY = Math.random() * height; const cloudSize = Math.random() * (maxR - minR) + minR; for (let j = 0; j < 8; j++) { const offsetX = (Math.random() - 0.5) * cloudSize; const offsetY = (Math.random() - 0.5) * cloudSize; const radius = (Math.random() * 0.5 + 0.5) * cloudSize; tempCtx.beginPath(); tempCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2 + baseAlpha})`; tempCtx.arc(cloudX + offsetX, cloudY + offsetY, radius, 0, Math.PI * 2); tempCtx.fill(); } } return tempCanvas; }

        const world = { width: 1600, height: 1200 };
        const groundIslands = [{ id: 'start', x: world.width / 2, y: world.height * 0.75, sizeX: 500, sizeY: 350, density: 120 }, { id: 'saki', x: world.width / 2, y: world.height * 0.25, sizeX: 400, sizeY: 300, density: 90 }, { id: 'bridge1', x: world.width / 2, y: world.height * 0.5, sizeX: 150, sizeY: 400, density: 80 }];
        const backgroundLayers = [{ canvas: createCloudIslandLayer(world.width, world.height, groundIslands), speed: 0.9 }, { canvas: createDistantCloudLayer(world.width, world.height, 30, 80, 150, 0.8), speed: 0.7 }, { canvas: createDistantCloudLayer(world.width, world.height, 10, 150, 250, 0.3), speed: 0.5 }];

        let gameState;
        let stateTimer;
        let camera;
        let player, nyarl, boss, saki, dog, demonStain;
        let targetX, targetY;
        let bullets;
        let effects;

        const keys = { w: false, a: false, s: false, d: false, c: false, shift: false };

        let tutorialState;
        let chaseCenter;
        let wasdCheck = { w: false, a: false, s: false, d: false, all: false };
        let avoidSuccessCount = 0;
        let isTimeStopped = false;


        function resetGame() {
            gameState = 'TUTORIAL';
            stateTimer = 0; camera = { x: 0, y: 0 };
            player = { worldX: world.width / 2, worldY: world.height * 0.75, width: 48, height: 48, speed: 4, dreamCollapse: 0, shieldGauge: 100, isGuarding: false, shieldBreakTime: 0, isDodging: false, dodgeTimer: 0, dodgeCooldown: 0, isRolling: false, rollTimer: 0, rollSpeed: 9, stunTimer: 0, alpha: 1, rollAngle: 0, rollDirection: 0 };
            nyarl = { worldX: player.worldX - 80, worldY: player.worldY - 30, width: 40, height: 40, targetX: player.worldX, targetY: player.worldY, targetTimer: 0, alpha: 1, distanceState: 'medium', stateTimer: 180, minRadius: 80, maxRadius: 120, };
            boss = { worldX: world.width / 2, worldY: world.height * 0.20, radius: 0, maxRadius: 25, alpha: 0, color: '#E91E63', coreRadius: 10, coreColor: '#F44336', isActive: false, attackTimer: 0, isCharging: false, chargeTimer: 0, purificationGauge: 0, maxPurificationGauge: 100, isVulnerable: false, vulnerableTimer: 0, vy: 0 }; // ★★★ ボスのY座標をシミのターゲットYに合わせる ★★★

            chaseCenter = { x: world.width / 2, y: world.height * 0.25 };
            saki = { worldX: chaseCenter.x + 90, worldY: chaseCenter.y, width: 20, height: 30, alpha: 1, orbitAngle: 0, orbitRadius: 70, orbitSpeed: 0.02, centerX: chaseCenter.x, centerY: chaseCenter.y };
            dog = { worldX: chaseCenter.x - 90, worldY: chaseCenter.y, width: 25, height: 20, alpha: 1, isHit: false };
            demonStain = { worldX: world.width / 2, worldY: 0, radius: 0, alpha: 0, targetY: world.height * 0.10 };

            bullets = []; effects = [];

            tutorialState = 'STAIN_APPEAR';
            wasdCheck = { w: false, a: false, s: false, d: false, all: false };
            avoidSuccessCount = 0;
            isTimeStopped = false;

            hideTutorialText();
            messageOverlay.style.opacity = 0;
            wasdGuide.style.display = 'none';
            document.getElementById('titleScreen').style.display = 'block';
            document.getElementById('purificationGaugeContainer').style.opacity = 0;
            document.getElementById('purificationGauge').style.width = '0%';
            document.querySelectorAll('.status-display, .shield-display').forEach(el => el.style.opacity = '0');

            if (audioStarted) {
                Tone.Transport.stop();
                Tone.Transport.cancel(0);
                if (battleBGM) battleBGM.stop();
                if (peacefulBGM) peacefulBGM.stop();
            }

            // ★★★ ここから下を丸ごと差し替え！ (デバッグ用ワープ処理) ★★★
            // 'START' 以外からゲームを始める場合のみ、この中の処理が実行される
            if (tutorialState !== 'START') {
                // まずは共通の準備：タイトルを飛ばしてゲーム画面を表示する
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('loading-text').style.display = 'none';
                canvas.style.display = 'block';
                document.getElementById('instructions').style.display = 'block';

                // 開始するシーンが「戦闘」か「演出」かを判断するためのリスト
                // ★★★ このリストを更新！ ★★★
                const cinematicStartStates = ['STAIN_APPEAR', 'DOG_STOPS', 'DEMON_GROW', 'DOG_BARKS', 'DOG_DOWN'];
                const battleStartStates = ['BATTLE_AVOID_ONLY', 'LESSON_SPOT_DODGE', 'LESSON_ROLL_DODGE', 'LESSON_GUARD', 'LESSON_GUARD_SUCCESS'];

                // --- 演出シーンから始める場合の下準備 ---
                // --- 演出シーンから始める場合の下準備 ---
                if (cinematicStartStates.includes(tutorialState)) {
                    // シミ出現前なら、シミを透明に
                    if (tutorialState === 'STAIN_APPEAR') {
                        demonStain.alpha = 0; // ここからフェードイン
                    }
                    // シミが出現済みのシーンからなら、シミを表示しておく
                    else if (['DOG_STOPS', 'DEMON_GROW', 'DOG_BARKS', 'DOG_DOWN'].includes(tutorialState)) {
                        demonStain.alpha = 0; // シミ自体は消滅するので0にしておく
                        boss.alpha = 0.8; // ボスを出現させておく（DEMON_GROWでフェードインするのでこのくらい）
                        boss.radius = boss.maxRadius + 10; // ボスも大きくなっている
                    }
                }
                // --- 戦闘シーンから始める場合の下準備 ---
                else if (battleStartStates.includes(tutorialState)) {
                    // 戦闘用のキャラクター配置やUI表示を行う
                    player.worldY = world.height * 0.6; // 戦闘エリアに移動
                    saki.alpha = 0;   // サキちゃんはもういない
                    dog.alpha = 0;    // 犬ももういない
                    boss.alpha = 1;   // ボスは完全に姿を現している
                    boss.radius = boss.maxRadius;
                    boss.isActive = true;

                    document.getElementById('purificationGaugeContainer').style.opacity = 1;
                    document.querySelectorAll('.status-display, .shield-display').forEach(el => el.style.opacity = '1');

                    // BGMを戦闘用のものに設定する
                    if (audioStarted) {
                        if (peacefulBGM.state === 'started') peacefulBGM.stop();
                        if (battleBGM.state !== 'started') battleBGM.start();
                        Tone.Transport.start();
                    }
                }
            }
            // ★★★ 差し替えはここまで ★★★
        }

        // ★★★ サキちゃんだけを動かす関数 ★★★
        function updateSakiMovement() {
            saki.orbitAngle += saki.orbitSpeed;
            saki.worldX = saki.centerX + Math.cos(saki.orbitAngle) * saki.orbitRadius;
            saki.worldY = saki.centerY + Math.sin(saki.orbitAngle) * saki.orbitRadius;
        }

        // ★★★ 犬だけを動かす関数 ★★★
        function updateDogMovement() {
            const targetDogX = saki.centerX + Math.cos(saki.orbitAngle - 0.8) * saki.orbitRadius;
            const targetDogY = saki.centerY + Math.sin(saki.orbitAngle - 0.8) * saki.orbitRadius;
            dog.worldX += (targetDogX - dog.worldX) * 0.07;
            dog.worldY += (targetDogY - dog.worldY) * 0.07;
        }

        // 追いかけっこシーンを更新する専用の関数
        function updateChaseScene() {
            updateSakiMovement();
            updateDogMovement();
        }

        function updateTutorial() {
            stateTimer++;
            switch (tutorialState) {
                case 'START':
                    showTutorialText("ニャル:「初めての夢の世界だよ！好きに動いていいよ！」");
                    wasdGuide.style.display = 'flex';
                    tutorialState = 'WASD_GUIDE';
                    break;

                case 'WASD_GUIDE':
                    updateChaseScene();
                    if (wasdCheck.all) {
                        wasdGuide.style.display = 'none';
                        showTutorialText("ニャル:「うん、上手だね！あの子たちのところまで行ってみよう！」");
                        tutorialState = 'GO_TO_SAKI';
                        stateTimer = 0; // ★★★ この一行を追加！ ★★★
                    }
                    break;

                case 'GO_TO_SAKI':
                    updateChaseScene(); // ★★★ ここでも呼び出す ★★★
                    // const sakiScreenY = saki.worldY - camera.y;
                    // if (sakiScreenY < canvas.height && sakiScreenY > 0) {
                    //    tutorialState = 'START_CONVERSATION';
                    // }
                    // ★★★ この部分を丸ごと変更！一定時間後にシミ出現シーンへ遷移★★★
                    // プレイヤーがWASDを全部押した後、約5秒後にシミ出現
                    if (stateTimer > 240) { // 300フレーム = 5秒
                        hideTutorialText();
                        tutorialState = 'STAIN_APPEAR'; // シミ出現シーンへ
                        stateTimer = 0;
                    }
                    break;

                case 'START_CONVERSATION':
                    showTutorialText("ニャル:「楽しそうだね…」"); // セリフを表示して
                    stateTimer = 0;                           // タイマーをリセットして
                    tutorialState = 'WATCHING_PLAY';          // すぐに次の状態へ移行！
                    break;
                case 'WATCHING_PLAY':
                    updateChaseScene();
                    if (stateTimer === 180) showTutorialText("主人公:「…うん」");
                    if (stateTimer > 300) {
                        hideTutorialText();
                        tutorialState = 'STAIN_APPEAR';
                        stateTimer = 0;
                    }
                    break;
                case 'STAIN_APPEAR':
                    updateChaseScene(); // 犬たちは回り続ける

                    // シミがフェードインしながら、だんだん近づいてくる
                    demonStain.alpha = Math.min(0.8, demonStain.alpha + 0.005);
                    demonStain.radius = Math.min(40, demonStain.radius + 0.5);

                    // シミをアニメーションさせる処理
                    if (demonStain.worldY < demonStain.targetY) {
                        demonStain.worldY += 0.7;
                    } else {
                        demonStain.worldY = demonStain.targetY;
                    }

                    if (stateTimer === 1) showTutorialText("なにやら、黒いシミが浮かんでいる…");

                    // シミがゴール地点に着いたら、次のシーンに進む
                    if (demonStain.worldY >= demonStain.targetY) {
                        hideTutorialText();
                        tutorialState = 'DOG_STOPS_ONLY';
                        stateTimer = 0;
                    }
                    break;

                // ★★★ ここから下の2つのcaseを、古い'DOG_STOPS'と入れ替える ★★★

                case 'DOG_STOPS_ONLY':
                    // 犬だけが止まり、サキちゃんは走り続ける
                    updateSakiMovement(); // サキちゃんだけを動かす！

                    // 2秒くらい経ったら、サキちゃんも止まるステップへ
                    if (stateTimer > 120) { // 2秒 = 120フレーム
                        tutorialState = 'SAKI_STOPS_TOO';
                        stateTimer = 0;
                    }
                    break;

                case 'SAKI_STOPS_TOO':
                    // 今度はサキちゃんも止まる（誰も動かさない）

                    if (stateTimer === 1) showTutorialText("ニャル:「…！ なにあれ…？」"); // ここでニャルが気づく

                    // 3秒くらい間を置いたら、悪魔が実体化するステップへ
                    if (stateTimer > 180) { // 3秒 = 180フレーム
                        hideTutorialText();
                        tutorialState = 'DEMON_GROW';
                        stateTimer = 0;
                    }
                    break;

                // ★★★ 入れ替えはここまで ★★★

                // case 'DOG_STOPS':
                //     // サキちゃんと犬の動きを止める (updateChaseScene()は呼ばない)
                //     // シミは既にフェードインしている

                //     if (stateTimer === 1) showTutorialText("ニャル:「…！ なにあれ…？」"); // シミに気づくセリフ

                //     // 3秒くらい間を置いたら、悪魔が実体化するステップへ
                //     if (stateTimer > 180) { // 3秒 = 180フレーム
                //         hideTutorialText();
                //         tutorialState = 'DEMON_GROW'; // 悪魔が実体化するシーンへ
                //         stateTimer = 0;
                //     }
                //     break;

                // case 'DOG_BARKS_SAKI_STOPS':
                //     // 犬が吠え始めたら、サキちゃんも止まる
                //     // (ここではSakiとDogの移動関数をどちらも呼ばない)

                //     if (stateTimer === 1) showTutorialText("ニャル:「…！ なにあれ…？」");

                //     /* 犬がシミに向かって吠える
                //     if (dog.alpha > 0) {
                //         if (stateTimer % 40 < 20) { dog.worldY -= 2; } else { dog.worldY += 2; }
                //     }
                //     */

                //     // 2秒間吠えたら、悪魔が実体化するステップへ
                //     if (stateTimer > 120) {
                //         hideTutorialText();
                //         tutorialState = 'DEMON_GROW';
                //         stateTimer = 0;
                //     }
                //     break;

                case 'DEMON_GROW':
                    // シミの位置は完全に固定
                    demonStain.worldY = demonStain.targetY;

                    if (stateTimer === 1) {
                        boss.alpha = 1;
                        boss.worldY = demonStain.targetY;
                        boss.radius = 0;
                        boss.vy = -10; // ★ ジャンプの高さ（マイナスが大きいほど高い）

                        const particleCount = 50;
                        for (let i = 0; i < particleCount; i++) {
                            effects.push(new CloudSplashParticle(demonStain.worldX, demonStain.targetY));
                        }
                        showTutorialText("ニャル:「うわっ！？なんだ、あの子は…！」");
                    }

                    // ★★★ ここからが新しいジャンプ＆落下アニメーション ★★★
                    if (stateTimer > 1) {
                        const finalBossY = demonStain.targetY; // ★ 最終的に止まる高さ

                        // ボスが最終地点より上にいるか、まだ上昇中の場合だけ物理演算を適用
                        if (boss.worldY < finalBossY || boss.vy < 0) {
                            boss.vy += 0.4; // ★ 重力の強さ
                            boss.worldY += boss.vy;
                        } else {
                            // 最終地点に落ちてきたら、そこで固定する
                            boss.worldY = finalBossY;
                        }

                        // 拡大アニメーション
                        const finalRadius = boss.maxRadius + 10;
                        if (boss.radius < finalRadius) {
                            boss.radius += (finalRadius - boss.radius) * 0.1;
                        }
                    }

                    // サキちゃんへの攻撃と消滅、次のシーンへの移行
                    if (stateTimer === 30) {
                        bullets.push(new CoughBullet(boss.worldX, boss.worldY, 0, saki, true));
                        playSound('cough');
                    }
                    if (stateTimer > 90) {
                        saki.alpha = Math.max(0, saki.alpha - 0.02);
                    }
                    if (stateTimer > 120 && saki.alpha <= 0) {
                        stateTimer = 0;
                        tutorialState = 'DOG_BARKS';
                    }
                    break;

                // case 'DEMON_EMERGE_FROM_CLOUD':
                //     // 悪魔をゆっくりとフェードインさせる
                //     // alpha (透明度) を少しずつ上げていく
                //     if (boss.alpha < 1) { // まだ完全に不透明じゃない場合
                //         boss.alpha += 0.01; // 1フレームごとに0.01ずつ透明度を上げる（数字を大きくすると速くなる）
                //         if (boss.alpha > 1) boss.alpha = 1; // 1を超えないように調整
                //     }

                //     // お好みで、悪魔のサイズも少し大きくする演出を加えてもいいかも
                //     // boss.radius += (30 - boss.radius) * 0.02; // 例：目標半径30にゆっくり近づける

                //     // ある程度の時間が経つか、完全に姿を現したら次のシーンへ
                //     if (stateTimer > 90 || boss.alpha >= 1) { // 90フレーム（約1.5秒）経つか、完全に現れたら
                //         stateTimer = 0;
                //         tutorialState = 'DOG_BARKS'; // 犬が吠える本来のシーンへ
                //     }
                //     break;

                case 'BOSS_ZOOM_IN':

                    // じわ～っと目標サイズに近づける処理
                    boss.radius += (targetRadius - boss.radius) * 0.05;

                    // 2秒くらい経ったら、本来の次のシーン（犬が吠える）に進む
                    if (stateTimer > 120) {
                        stateTimer = 0;
                        tutorialState = 'DOG_BARKS';
                    }
                    break;

                case 'DOG_BARKS':
                    // ボスの方を向いて、3回吠える動き
                    dog.targetX = boss.worldX;
                    dog.worldX += (dog.targetX - dog.worldX) * 0.02;
                    if (dog.alpha > 0) { // 犬が見えている場合のみアニメーション
                        if (stateTimer % 40 < 20) { dog.worldY -= 3; } else { dog.worldY += 3; } // 上下に動かす
                    }

                    // 3回吠え終わったら（120フレーム後）、犬が攻撃されるステップへ
                    if (stateTimer > 120) {
                        // ★★★ 犬に向けて咳攻撃を発射 ★★★
                        bullets.push(new CoughBullet(boss.worldX, boss.worldY, 0, dog, false, true));
                        playSound('cough');
                        tutorialState = 'DOG_DOWN';
                        stateTimer = 0;
                    }
                    break;

                case 'DOG_DOWN':
                    // ★★★ if文の条件を変更！ ★★★
                    // 弾が当たったら(isHitがtrueになったら)、犬が消え始める
                    if (dog.isHit) {
                        dog.alpha = Math.max(0, dog.alpha - 0.02);
                    }

                    // 犬が完全に消えたら、いよいよ戦闘開始
                    if (dog.alpha <= 0) { // ← ここの条件は .alpha のままでOK
                        // ... (戦闘開始の処理) ...
                    }
                    break;
                case 'BATTLE_AVOID_ONLY':
                    if (avoidSuccessCount >= 3) {
                        tutorialState = 'LESSON_SPOT_DODGE';
                        stateTimer = 0;
                    }
                    break;

                case 'LESSON_SPOT_DODGE':
                    // 最初の1フレームだけ実行
                    if (stateTimer === 1) {
                        showTutorialText("ニャル:「今のままじゃ避けきれない！<span>Shiftキー</span>で、その場で素早く回避できるよ！」");

                        isTimeStopped = true; // 時間を止める！

                        // チュートリアル用の咳攻撃を1発だけ発射
                        const angle = Math.atan2(player.worldY - boss.worldY, player.worldX - boss.worldX);
                        bullets.push(new CoughBullet(boss.worldX, boss.worldY, angle, null, false, true)); // isTutorialBulletをtrueに
                        playSound('cough');

                        tutorialState = 'LESSON_WAIT_FOR_DODGE';
                    }
                    break;

                case 'LESSON_WAIT_FOR_DODGE':
                    // このシーンでは何もしない。弾が止まって、プレイヤーの入力を待つだけ。
                    break;
                case 'LESSON_ROLL_DODGE': break;
                case 'LESSON_GUARD': break;
                case 'BATTLE_END':
                    if (stateTimer > 180) {
                        showMessage("浄化成功");
                        playSound('purify');
                        gameState = 'CLEAR';
                    }
                    break;
            }
        }

        function updateNyarl() {
            if (!nyarl) return;
            if (!['WATCHING_PLAY', 'STAIN_APPEAR', 'DEMON_GROW', 'DOG_BARKS', 'DOG_DOWN'].includes(tutorialState)) {
                nyarl.stateTimer--;
                nyarl.targetTimer--;

                if (nyarl.stateTimer <= 0) {
                    const possibleStates = ['short', 'medium', 'long'].filter(s => s !== nyarl.distanceState);
                    const newState = possibleStates[Math.floor(Math.random() * possibleStates.length)];
                    nyarl.distanceState = newState;

                    switch (newState) {
                        case 'short': nyarl.stateTimer = 120; nyarl.minRadius = 50; nyarl.maxRadius = 80; break;
                        case 'medium': nyarl.stateTimer = 180; nyarl.minRadius = 80; nyarl.maxRadius = 120; break;
                        case 'long': nyarl.stateTimer = 300; nyarl.minRadius = 120; nyarl.maxRadius = 160; break;
                    }
                }

                if (nyarl.targetTimer <= 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = nyarl.minRadius + Math.random() * (nyarl.maxRadius - nyarl.minRadius);
                    nyarl.targetX = player.worldX + Math.cos(angle) * radius;
                    nyarl.targetY = player.worldY + Math.sin(angle) * radius;
                    nyarl.targetTimer = Math.random() * 60 + 60;
                }
            } else {
                nyarl.targetX = player.worldX - 80;
                nyarl.targetY = player.worldY - 30;
            }
            nyarl.worldX += (nyarl.targetX - nyarl.worldX) * 0.05;
            nyarl.worldY += (nyarl.targetY - nyarl.worldY) * 0.05;
        }

        function update() {
            // 時間が止まっている時の処理
            if (isTimeStopped) {
                // 時間停止中でも、弾とエフェクトだけは更新する
                updateBullets();
                effects.forEach((e, i) => { e.update(); if (e.life <= 0) effects.splice(i, 1); });
                return; // 他の処理はすべてここで止める
            }

            // 通常時の処理（時間が動いている時）
            if (gameState === 'TUTORIAL' || gameState === 'TUTORIAL_BATTLE') {
                updateTutorial();
            }
            const playerCanMove = !['STAIN_APPEAR', 'DOG_STOPS_ONLY', 'SAKI_STOPS_TOO', 'DEMON_GROW', 'DOG_BARKS', 'DOG_DOWN', 'LESSON_SPOT_DODGE', 'LESSON_WAIT_FOR_DODGE'].includes(tutorialState);
            if (gameState !== 'TITLE' && playerCanMove) {
                updatePlayer();
            }
            if (gameState !== 'TITLE') {
                updateNyarl();
            }
            if (bullets.length > 0) {
                updateBullets();
            }
            if (gameState === 'TUTORIAL_BATTLE' && boss.isActive) {
                handleBattleAttacks();
                checkCollisions();
            }
            if (gameState !== 'TITLE') {

                // ★★★ ここから下のカメラ処理を丸ごと追加！ ★★★
                const chaseCinematicStates = ['STAIN_APPEAR', 'DOG_STOPS_ONLY'];
                const demonCinematicStates = ['SAKI_STOPS_TOO', 'DEMON_GROW', 'DOG_BARKS', 'DOG_DOWN'];

                if (chaseCinematicStates.includes(tutorialState)) {
                    targetX = chaseCenter.x;
                    targetY = chaseCenter.y;
                } else if (demonCinematicStates.includes(tutorialState)) {
                    targetX = demonStain.worldX;
                    targetY = demonStain.targetY;
                } else {
                    targetX = player.worldX;
                    targetY = player.worldY;
                }

                camera.x += (targetX - canvas.width / 2 - camera.x) * 0.08;
                camera.y += (targetY - canvas.height / 2 - camera.y) * 0.08;
                camera.x = Math.max(0, Math.min(world.width - canvas.width, camera.x));
                camera.y = Math.max(0, Math.min(world.height - canvas.height, camera.y));
                // ★★★ 追加はここまで ★★★

                // ... (カメラの処理はそのまま) ...
                effects.forEach((e, i) => { e.update(); if (e.life <= 0) effects.splice(i, 1); });
            }
        }

        function isPositionOnCloud(x, y) {
            if (!groundCloudCtx) return false;

            if (x < 0 || x >= world.width || y < 0 || y >= world.height) return false;
            const pixelData = groundCloudCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
            return pixelData[3] > 0;
        }
        function updatePlayer() {
            if (player.stunTimer > 0) {
                player.stunTimer--; return;
            }
            if (player.shieldBreakTime > 0) {
                player.shieldBreakTime--; return;
            }
            if (player.dodgeTimer > 0) {
                player.dodgeTimer--;
            }
            else
                player.isDodging = false;

            if (player.rollTimer > 0) {
                player.rollTimer--;
                player.rollAngle += 0.5;
            }
            else player.isRolling = false;
            if (player.dodgeCooldown > 0)
                player.dodgeCooldown--;
            player.isGuarding = keys.c && player.shieldGauge > 0;

            if (player.isGuarding) {
                if (!isGuardSoundPlaying) {
                    sounds.guard.triggerAttack("C2");
                    isGuardSoundPlaying = true;
                }
                player.shieldGauge -= 0.5;
                if (player.shieldGauge <= 0) {
                    player.shieldBreakTime = 120;
                    playSound('hit');
                }
            }
            else {
                if (isGuardSoundPlaying) {
                    sounds.guard.triggerRelease();
                    isGuardSoundPlaying = false;
                }
                if (player.shieldGauge < 100) player.shieldGauge += 0.3;
            }
            let moveX = 0; let moveY = 0;
            if (player.isRolling) {
                moveX = player.rollDirection * player.rollSpeed;
            }
            else if (!player.isGuarding) {
                if (keys.w) moveY -= player.speed;
                if (keys.s) moveY += player.speed;
                if (keys.a) moveX -= player.speed;
                if (keys.d) moveX += player.speed;
            }
            let nextX = player.worldX + moveX;
            let nextY = player.worldY + moveY;
            if (isPositionOnCloud(nextX, player.worldY))
                player.worldX = nextX;
            if (isPositionOnCloud(player.worldX, nextY)) player.worldY = nextY;
        }

        function handleBattleAttacks() {
            if (!boss.isActive || boss.isVulnerable) return;

            if (tutorialState === 'BATTLE_AVOID_ONLY') {
                if (boss.attackTimer % 150 === 0 && bullets.length === 0) {
                    const angle = Math.atan2(player.worldY - boss.worldY, player.worldX - boss.worldX);
                    bullets.push(new CoughBullet(boss.worldX, boss.worldY, angle));
                    playSound('cough');
                }
            } else if (['LESSON_SPOT_DODGE', 'LESSON_ROLL_DODGE', 'LESSON_GUARD', 'LESSON_GUARD_SUCCESS'].includes(tutorialState)) {
                if (boss.attackTimer % 120 === 0 && bullets.length === 0) {
                    const angle = Math.atan2(player.worldY - boss.worldY, player.worldX - boss.worldX);
                    bullets.push(new CoughBullet(boss.worldX, boss.worldY, angle));
                    playSound('cough');
                }
            }
            boss.attackTimer++;
        }

        function updateBullets() {
            bullets.forEach((b, i) => {
                b.update();
                const screenX = b.worldX - camera.x;
                const screenY = b.worldY - camera.y;
                if (screenX < -b.radius || screenX > canvas.width + b.radius || screenY < -b.radius || screenY > canvas.height + b.radius) {
                    if (tutorialState === 'BATTLE_AVOID_ONLY' && !b.isForSaki && !b.isForDog) {
                        avoidSuccessCount++;
                    }
                    bullets.splice(i, 1);
                }
            });
        }

        class CoughBullet {
            constructor(x, y, angle, target = null, isForSaki = false, isTutorialBullet = false) {
                this.worldX = x; this.worldY = y; this.radius = 5; this.speed = 3; this.life = 480;
                this.target = target; this.isForSaki = isForSaki;

                // --- ここからが追加・変更部分 ---
                this.isTutorialBullet = isTutorialBullet; // チュートリアル用の弾かどうかの目印
                this.isFrozen = false; // チュートリアル用に停止しているかどうかの目印

                // チュートリアル用の弾なら、スピードを少し遅くする
                if (this.isTutorialBullet) {
                    this.speed = 2;
                }
                // --- ここまで ---

                if (target) { const targetAngle = Math.atan2(target.worldY - y, target.worldX - x); this.vx = Math.cos(targetAngle) * this.speed; this.vy = Math.sin(targetAngle) * this.speed; }
                else { this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; }
            }

            update() {
                // もしチュートリアル弾で、かつフリーズ中なら、ここで動きを止める
                if (this.isTutorialBullet && this.isFrozen) {
                    return;
                }

                // プレイヤーとの距離を計算
                const distToPlayer = Math.hypot(this.worldX - player.worldX, this.worldY - player.worldY);

                // もしチュートリアル弾で、プレイヤーの近くまで来たらフリーズする
                if (this.isTutorialBullet && distToPlayer < 50) { // 50ピクセル手前で止まる
                    this.isFrozen = true;
                    return; // 動きを止める
                }

                // 通常の移動処理
                this.worldX += this.vx; this.worldY += this.vy; this.radius += 0.05;
                this.life--;
                if (this.target && this.target.alpha > 0 && Math.hypot(this.worldX - this.target.worldX, this.worldY - this.target.worldY) < 20) {
                    if (this.target.isHit !== undefined) {
                        this.target.isHit = true; // ターゲットの isHit フラグを立てる
                    } else {
                        this.target.alpha = 0; // isHit がないターゲットは即死
                    }
                    this.life = 0; // 弾は消える
                }
            }

            draw(ctx, camera) { const x = this.worldX - camera.x; const y = this.worldY - camera.y; const alpha = Math.min(1, this.life / 60); ctx.beginPath(); ctx.fillStyle = `rgba(139, 195, 74, ${0.4 * alpha})`; ctx.arc(x, y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.fillStyle = `rgba(205, 220, 57, ${0.3 * alpha})`; ctx.arc(x, y, this.radius * 0.6, 0, Math.PI * 2); ctx.fill(); }
        }
        function createGaugeEffect() { for (let i = 0; i < 5; i++) { effects.push(new GaugeParticle(player.worldX, player.worldY)); } }
        class GaugeParticle { constructor(x, y) { this.worldX = x; this.worldY = y; this.life = 20; this.radius = Math.random() * 3 + 1; this.vx = (Math.random() - 0.5) * 2; this.vy = -Math.random() * 2 - 1; } update() { this.worldX += this.vx; this.worldY += this.vy; this.life--; } draw(ctx, camera) { const x = this.worldX - camera.x; const y = this.worldY - camera.y; ctx.fillStyle = `rgba(0, 188, 212, ${this.life / 20})`; ctx.beginPath(); ctx.arc(x, y, this.radius, 0, Math.PI * 2); ctx.fill(); } }

        class CloudSplashParticle {
            constructor(x, y) {
                this.worldX = x;
                this.worldY = y;
                this.life = Math.random() * 50 + 30; // 一瞬だけ表示
                this.initialLife = this.life;

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 4; // 初速を少しアップ
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed - 2; // 最初、少しだけ上に飛び上がる力を与える

                this.radius = Math.random() * 4 + 2; // パーティクルを少し小さく、鋭くする
                this.color = `rgba(180, 180, 180, ${Math.random() * 0.4 + 0.3})`; // 少し明るく、透明度を高くする
            }

            update() {
                this.worldX += this.vx;
                this.worldY += this.vy;

                // ★★★ 重力を追加！ これで下に落ちるようになる ★★★
                this.vy += 0.15;

                // 空気抵抗で少しずつ減速
                this.vx *= 0.99;

                this.life--;
            }

            draw(ctx, camera) {
                const x = this.worldX - camera.x;
                const y = this.worldY - camera.y;

                // 命が尽きるにつれて、だんだん透明になって消える
                ctx.globalAlpha = (this.life / this.initialLife);
                const lifeRatio = this.life / this.initialLife; // 残り寿命の割合 (1.0 ～ 0.0)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(x, y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ScreenFlash {
            constructor() {
                this.life = 20; // 1/3秒くらいで消える
            }
            update() {
                this.life--;
            }
            draw(ctx, camera) {
                // 画面全体を、だんだん透明になる白い四角形で覆う
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life / 20 * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function checkCollisions() {

            if (!boss.isActive) return;

            bullets.forEach((b, i) => {
                if (b.isForSaki || b.isForDog) return;
                const dist = Math.hypot(player.worldX - b.worldX, player.worldY - b.worldY);
                if (dist < player.width / 2 + b.radius) {
                    if (player.isDodging) { // "その場回避" の場合
                        // ★★★ この一行を追加！ ★★★
                        if (tutorialState === 'LESSON_SPOT_DODGE') {
                            // まだ時間が止まっていなければ、時間停止処理を開始
                            if (!isTimeStopped) {
                                isTimeStopped = true;
                                playSound('parry');
                                effects.push(new ScreenFlash());

                                // 1.5秒後に時間停止を解除
                                setTimeout(() => {
                                    isTimeStopped = false;
                                }, 1500);
                            }
                        } // ★★★ 追加したif文の閉じカッコ ★★★
                        bullets.splice(i, 1);
                        return;
                    }
                    else if (player.isRolling) {
                        bullets.splice(i, 1);
                        return;
                    }
                    if (player.isGuarding) { } else { playSound('hit'); }
                    bullets.splice(i, 1);
                }
            });

            if (boss.isActive && !boss.isVulnerable && tutorialState === 'LESSON_GUARD_SUCCESS') {
                boss.purificationGauge += 2;
                document.getElementById('purificationGauge').style.width = `${(boss.purificationGauge / boss.maxPurificationGauge) * 100}%`;
                if (boss.purificationGauge >= boss.maxPurificationGauge) {
                    boss.isVulnerable = true;
                    tutorialState = 'BATTLE_END';
                    stateTimer = 0;
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#75cff0'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (gameState !== 'TITLE') {
                backgroundLayers.forEach(layer => { const layerX = -camera.x * layer.speed; const layerY = -camera.y * layer.speed; const imgWidth = layer.canvas.width; const imgHeight = layer.canvas.height; for (let y = layerY % imgHeight - imgHeight; y < canvas.height + imgHeight; y += imgHeight) { for (let x = layerX % imgWidth - imgWidth; x < canvas.width + imgWidth; x += imgWidth) { ctx.drawImage(layer.canvas, x, y); } } });

                const drawObj = (obj, img = null, alpha = 1) => {
                    if (!obj || obj.alpha <= 0) return;
                    const x = obj.worldX - camera.x; const y = obj.worldY - camera.y;
                    ctx.globalAlpha = alpha;
                    if (img && img.complete && img.naturalHeight !== 0) { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x, y + obj.height / 2, obj.width / 2.2, obj.width / 4, 0, 0, Math.PI * 2); ctx.fill(); ctx.drawImage(img, x - obj.width / 2, y - obj.height / 2, obj.width, obj.height); }
                    else { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x, y + obj.height / 2, obj.width / 2.2, obj.width / 4, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = obj.color || '#000000'; ctx.fillRect(x - obj.width / 2, y - obj.height / 2, obj.width, obj.height); }
                    ctx.globalAlpha = 1;
                };
                const drawCirc = (obj) => {
                    if (!obj || obj.alpha <= 0) return;
                    const x = obj.worldX - camera.x, y = obj.worldY - camera.y;
                    ctx.globalAlpha = obj.alpha * ((obj.isVulnerable && Math.floor(stateTimer / 10) % 2 === 0) ? 0.5 : 1.0);
                    // ▼▼▼ この2行が影を描いている部分 ▼▼▼
                    // ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    // ctx.beginPath(); ctx.ellipse(x, y + obj.radius, obj.radius, obj.radius * 0.5, 0, 0, Math.PI * 2); ctx.fill();
                    // ▲▲▲ ここまで ▲▲▲                    ctx.fillStyle = (obj.isVulnerable) ? '#B2EBF2' : obj.color; ctx.beginPath(); ctx.arc(x, y, obj.radius, 0, Math.PI * 2); ctx.fill();
                    if (obj.coreRadius) { ctx.fillStyle = (obj.isVulnerable) ? '#FFFFFF' : obj.coreColor; ctx.beginPath(); ctx.arc(x, y, obj.coreRadius, 0, Math.PI * 2); ctx.fill(); }
                    ctx.globalAlpha = 1.0;
                };

                // シミを描画する処理
                // ★★★ このブロックを丸ごと差し替える ★★★
                if (demonStain && demonStain.alpha > 0) {
                    const x = demonStain.worldX - camera.x;
                    const y = demonStain.worldY - camera.y;
                    ctx.globalAlpha = demonStain.alpha;
                    ctx.fillStyle = '#212121';

                    // ★★★ ここが雲の形の設計図！ ★★★
                    // [中心からのX位置, Y位置, 大きさ] の比率を決めておく
                    const cloudBlobs = [
                        // --- 奥のレイヤー ---
                        { x: -0.5, y: 0.1, r: 0.7 },
                        { x: 0.4, y: 0.2, r: 0.8 },
                        { x: 0.1, y: 0.3, r: 0.6 },

                        // --- 手前のレイヤー ---
                        { x: 0.0, y: -0.1, r: 1.0 },
                        { x: -0.6, y: -0.2, r: 0.8 },
                        { x: 0.6, y: -0.15, r: 0.9 }
                    ];

                    ctx.beginPath();

                    // 設計図を元に、各パーツを描画
                    cloudBlobs.forEach(blob => {
                        const blobX = x + blob.x * demonStain.radius;
                        const blobY = y + blob.y * demonStain.radius;

                        const blobRadiusX = blob.r * demonStain.radius;
                        // この0.5を小さくすると、もっと平べったくなって奥行き感が増すよ
                        const blobRadiusY = blobRadiusX * 0.5;

                        ctx.ellipse(blobX, blobY, blobRadiusX, blobRadiusY, 0, 0, Math.PI * 2);
                    });

                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                const objectsToDraw = [...bullets, ...effects, saki, dog, boss, nyarl, player].filter(Boolean);
                objectsToDraw.sort((a, b) => (a.worldY + (a.height || a.radius || 0)) - (b.worldY + (b.height || a.radius || 0)));
                objectsToDraw.forEach(obj => {
                    if (obj.draw) { obj.draw(ctx, camera); }
                    else if (obj === player) { drawPlayer(); }
                    else if (obj === nyarl) { drawObj(obj, assets.nyarl.img, obj.alpha); }
                    else if (obj === boss) { drawCirc(obj); }
                    else if (obj === saki || obj === dog) { drawObj(obj, null, obj.alpha); }
                });
                drawUI();
            }

            // ★★★ このデバッグコードを draw() 関数の最後に追加！ ★★★
            ctx.fillStyle = 'lime'; // 見やすいように緑色で
            ctx.font = '20px monospace';
            ctx.textAlign = 'right'; // 右下に表示
            ctx.fillText(`Dog alpha: ${dog.alpha.toFixed(2)}`, 790, 580);
            ctx.fillText(`State: ${tutorialState}`, 790, 560);

        }
        function drawPlayer() { const x = player.worldX - camera.x; const y = player.worldY - camera.y; ctx.save(); ctx.translate(x, y); ctx.globalAlpha = (player.isDodging || (player.shieldBreakTime > 0 && Math.floor(stateTimer / 10) % 2 === 0)) ? 0.5 : 1.0; if (player.isRolling) { player.rollAngle += 0.5; ctx.rotate(player.rollAngle); } ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(0, player.height / 2, player.width / 2.2, player.width / 4, 0, 0, Math.PI * 2); ctx.fill(); if (assets.player.img.complete && assets.player.img.naturalHeight !== 0) { ctx.drawImage(assets.player.img, -player.width / 2, -player.height / 2, player.width, player.height); } else { ctx.fillStyle = player.color || '#4CAF50'; ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height); } ctx.restore(); if (player.isGuarding) { ctx.strokeStyle = `rgba(33, 150, 243, ${player.shieldGauge / 100})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.ellipse(x, y, 25, 15, 0, 0, Math.PI * 2); ctx.stroke(); } if (player.shieldBreakTime > 0) { const dizzyY = y - player.height / 2 - 15; const angle = stateTimer * 0.1; ctx.fillStyle = '#FFEB3B'; ctx.font = '20px sans-serif'; ctx.textAlign = 'center'; for (let i = 0; i < 3; i++) { const starX = x + Math.cos(angle + i * (Math.PI * 2 / 3)) * 15; const starY = dizzyY + Math.sin(angle + i * (Math.PI * 2 / 3)) * 5; ctx.fillText('★', starX, starY); } } }
        function drawUI() { const uiElements = [document.getElementById('dreamCollapseDisplay'), document.getElementById('shieldDisplay')]; if (gameState === 'TUTORIAL_BATTLE' || gameState === 'CLEAR') { uiElements.forEach(el => el.style.opacity = '1'); } else { uiElements.forEach(el => el.style.opacity = '0'); } document.getElementById('dreamCollapseDisplay').textContent = `心の崩壊度: ${Math.floor(player.dreamCollapse)}%`; document.getElementById('shieldDisplay').textContent = `集中力: ${Math.floor(player.shieldGauge)}%`; if (player.shieldBreakTime > 0) { document.getElementById('shieldDisplay').textContent = "シールドブレイク！"; document.getElementById('shieldDisplay').style.color = "#f44336"; } else { document.getElementById('shieldDisplay').style.color = "#fff"; } }

        const tutorialText = document.getElementById('tutorialText'); const messageOverlay = document.getElementById('messageOverlay');
        window.addEventListener('keydown', (e) => {
            const key = e.key; const lowerKey = key.toLowerCase();
            if (gameState === 'TITLE' && lowerKey === ' ') {
                const startTutorialMusic = () => {
                    Tone.Transport.stop();
                    Tone.Transport.cancel(0);
                    if (battleBGM) battleBGM.stop();
                    if (peacefulBGM) peacefulBGM.start(0);
                    Tone.Transport.start();
                };
                if (!audioStarted) {
                    try { Tone.start().then(() => { setupSounds(); startTutorialMusic(); audioStarted = true; }); } catch (err) { console.error(err); }
                } else { startTutorialMusic(); }
                document.getElementById('titleScreen').style.display = 'none';
                gameState = 'TUTORIAL';
                return;
            }

            // ★★★ 動きがおかしくなる原因だった行を削除 ★★★
            // if (keys[lowerKey] !== undefined && tutorialState !== 'WASD_GUIDE') keys[lowerKey] = false;

            if (tutorialState === 'WASD_GUIDE') {
                if (['w', 'a', 's', 'd'].includes(lowerKey)) {
                    wasdCheck[lowerKey] = true;
                    document.getElementById(`key-${lowerKey}`).classList.add('pressed');
                    if (wasdCheck.w && wasdCheck.a && wasdCheck.s && wasdCheck.d) {
                        wasdCheck.all = true;
                    }
                }
            }

            keys[lowerKey] = true;

            if (key === 'Shift' && !player.isDodging && !player.isRolling && player.stunTimer <= 0 && player.dodgeCooldown <= 0) {

                // まずは「回避レッスンの真っ最中か？」をチェック
                if (tutorialState === 'LESSON_WAIT_FOR_DODGE') {
                    const tutorialBullet = bullets.find(b => b.isTutorialBullet);
                    // もしチュートリアル弾が目の前で止まっているなら…
                    if (tutorialBullet && tutorialBullet.isFrozen) {
                        // チュートリアル成功の処理！
                        isTimeStopped = false; // 時間を動かす
                        effects.push(new ScreenFlash());
                        playSound('parry');
                        bullets = [];
                        showTutorialText("ニャル:「うまい！その調子！」");
                        tutorialState = 'LESSON_ROLL_DODGE'; // 次のレッスンへ
                        return; // ← ここで処理を終わらせて、下の普通の回避はしない
                    }
                }

                playSound('dodge');
                player.dodgeCooldown = 60;
                if (keys.a || keys.d) {
                    player.isRolling = true;
                    player.rollTimer = 25;
                    player.rollAngle = 0;
                    player.rollDirection = keys.a ? -1 : 1;
                }
                else {
                    player.isDodging = true;
                    player.dodgeTimer = 30;
                }
            }

            if (lowerKey === 'c' && tutorialState === 'LESSON_GUARD') {
                isTimeStopped = false;
                hideTutorialText();
                tutorialState = 'LESSON_GUARD_SUCCESS';
                showTutorialText("ニャル:「完璧だ！心の力で、あの子を浄化しよう！」");
            }
            if (key === ' ' && (gameState === 'CLEAR')) { resetGame(); }
        });
        window.addEventListener('keyup', (e) => { const key = e.key; const lowerKey = key.toLowerCase(); if (keys[lowerKey] !== undefined) keys[lowerKey] = false; if (lowerKey === 'c') tryParry(); });
        function showTutorialText(text) { tutorialText.innerHTML = text; tutorialText.style.opacity = 1; }
        function hideTutorialText() { tutorialText.style.opacity = 0; }
        function showMessage(text) { messageOverlay.textContent = text; messageOverlay.style.opacity = 1; }
        function tryParry() { if (!gameState.includes('BATTLE') || boss.isVulnerable) return; let parried = false; bullets.forEach(b => { if (Math.hypot(player.worldX - b.worldX, player.worldY - b.worldY) < 50) parried = true; }); if (parried) { playSound('parry'); boss.purificationGauge += 35; createGaugeEffect(); let erased = 0; for (let i = bullets.length - 1; i >= 0; i--) { if (erased < 3 && Math.hypot(player.worldX - bullets[i].worldX, player.worldY - bullets[i].worldY) < 80) { bullets.splice(i, 1); erased++; } } } }

        function gameLoop() {
            if (gameState !== 'TITLE') {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>

</html>